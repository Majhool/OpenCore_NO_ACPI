/** @file
  Copyright (C) 2020, vit9696. All rights reserved.

  All rights reserved.

  This program and the accompanying materials
  are licensed and made available under the terms and conditions of the BSD License
  which accompanies this distribution.  The full text of the license may be found at
  http://opensource.org/licenses/bsd-license.php

  THE PROGRAM IS DISTRIBUTED UNDER THE BSD LICENSE ON AN "AS IS" BASIS,
  WITHOUT WARRANTIES OR REPRESENTATIONS OF ANY KIND, EITHER EXPRESS OR IMPLIED.
**/

#include "OcConsoleLibInternal.h"

#include <Uefi.h>
#include <Guid/AppleVariable.h>
#include <Library/BaseLib.h>
#include <Library/BaseMemoryLib.h>
#include <Library/DebugLib.h>
#include <Library/MemoryAllocationLib.h>
#include <Library/OcConsoleLib.h>
#include <Library/OcMiscLib.h>
#include <Library/UefiBootServicesTableLib.h>
#include <Library/UefiRuntimeServicesTableLib.h>
#include <Protocol/ConsoleControl.h>
#include <Protocol/GraphicsOutput.h>

/*
 * ISO Latin-1 Font
 *
 * Copyright (c) 2000
 * Ka-Ping Yee <ping@lfw.org>
 *
 * This font may be freely used for any purpose.
 */

#define ISO_CHAR_WIDTH   (8)
#define ISO_CHAR_HEIGHT  (16)

#define PAGE0_CHAR_MIN   (33)
#define PAGE0_CHAR_MAX   (127) ///< Use one over
#define PAGE0_FONT_HEAD  (1)
#define PAGE0_FONT_TAIL  (1)

STATIC UINT8  mIsoFontDataPage0[(PAGE0_CHAR_MAX - PAGE0_CHAR_MIN) * (ISO_CHAR_HEIGHT - PAGE0_FONT_HEAD - PAGE0_FONT_TAIL)] = {
  /*  33 */ 0x00, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x00, 0x18, 0x18, 0x00, 0x00, 0x00,
  /*  34 */ 0x00, 0x6c, 0x6c, 0x36, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  /*  35 */ 0x00, 0x00, 0x36, 0x36, 0x7f, 0x36, 0x36, 0x7f, 0x36, 0x36, 0x00, 0x00, 0x00, 0x00,
  /*  36 */ 0x08, 0x08, 0x3e, 0x6b, 0x0b, 0x0b, 0x3e, 0x68, 0x68, 0x6b, 0x3e, 0x08, 0x08, 0x00,
  /*  37 */ 0x00, 0x00, 0x33, 0x13, 0x18, 0x08, 0x0c, 0x04, 0x06, 0x32, 0x33, 0x00, 0x00, 0x00,
  /*  38 */ 0x00, 0x1c, 0x36, 0x36, 0x1c, 0x6c, 0x3e, 0x33, 0x33, 0x7b, 0xce, 0x00, 0x00, 0x00,
  /*  39 */ 0x00, 0x18, 0x18, 0x0c, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  /*  40 */ 0x00, 0x30, 0x18, 0x18, 0x0c, 0x0c, 0x0c, 0x0c, 0x0c, 0x18, 0x18, 0x30, 0x00, 0x00,
  /*  41 */ 0x00, 0x0c, 0x18, 0x18, 0x30, 0x30, 0x30, 0x30, 0x30, 0x18, 0x18, 0x0c, 0x00, 0x00,
  /*  42 */ 0x00, 0x00, 0x00, 0x00, 0x36, 0x1c, 0x7f, 0x1c, 0x36, 0x00, 0x00, 0x00, 0x00, 0x00,
  /*  43 */ 0x00, 0x00, 0x00, 0x00, 0x18, 0x18, 0x7e, 0x18, 0x18, 0x00, 0x00, 0x00, 0x00, 0x00,
  /*  44 */ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x18, 0x18, 0x0c, 0x00, 0x00,
  /*  45 */ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x7e, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  /*  46 */ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x18, 0x18, 0x00, 0x00, 0x00,
  /*  47 */ 0x00, 0x60, 0x20, 0x30, 0x10, 0x18, 0x08, 0x0c, 0x04, 0x06, 0x02, 0x03, 0x00, 0x00,
  /*  48 */ 0x00, 0x3e, 0x63, 0x63, 0x63, 0x6b, 0x6b, 0x63, 0x63, 0x63, 0x3e, 0x00, 0x00, 0x00,
  /*  49 */ 0x00, 0x18, 0x1e, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x00, 0x00, 0x00,
  /*  50 */ 0x00, 0x3e, 0x63, 0x60, 0x60, 0x30, 0x18, 0x0c, 0x06, 0x03, 0x7f, 0x00, 0x00, 0x00,
  /*  51 */ 0x00, 0x3e, 0x63, 0x60, 0x60, 0x3c, 0x60, 0x60, 0x60, 0x63, 0x3e, 0x00, 0x00, 0x00,
  /*  52 */ 0x00, 0x30, 0x38, 0x3c, 0x36, 0x33, 0x7f, 0x30, 0x30, 0x30, 0x30, 0x00, 0x00, 0x00,
  /*  53 */ 0x00, 0x7f, 0x03, 0x03, 0x3f, 0x60, 0x60, 0x60, 0x60, 0x63, 0x3e, 0x00, 0x00, 0x00,
  /*  54 */ 0x00, 0x3c, 0x06, 0x03, 0x03, 0x3f, 0x63, 0x63, 0x63, 0x63, 0x3e, 0x00, 0x00, 0x00,
  /*  55 */ 0x00, 0x7f, 0x60, 0x30, 0x30, 0x18, 0x18, 0x18, 0x0c, 0x0c, 0x0c, 0x00, 0x00, 0x00,
  /*  56 */ 0x00, 0x3e, 0x63, 0x63, 0x63, 0x3e, 0x63, 0x63, 0x63, 0x63, 0x3e, 0x00, 0x00, 0x00,
  /*  57 */ 0x00, 0x3e, 0x63, 0x63, 0x63, 0x7e, 0x60, 0x60, 0x60, 0x30, 0x1e, 0x00, 0x00, 0x00,
  /*  58 */ 0x00, 0x00, 0x00, 0x00, 0x18, 0x18, 0x00, 0x00, 0x00, 0x18, 0x18, 0x00, 0x00, 0x00,
  /*  59 */ 0x00, 0x00, 0x00, 0x00, 0x18, 0x18, 0x00, 0x00, 0x00, 0x18, 0x18, 0x0c, 0x00, 0x00,
  /*  60 */ 0x00, 0x60, 0x30, 0x18, 0x0c, 0x06, 0x06, 0x0c, 0x18, 0x30, 0x60, 0x00, 0x00, 0x00,
  /*  61 */ 0x00, 0x00, 0x00, 0x00, 0x7e, 0x00, 0x00, 0x7e, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  /*  62 */ 0x00, 0x06, 0x0c, 0x18, 0x30, 0x60, 0x60, 0x30, 0x18, 0x0c, 0x06, 0x00, 0x00, 0x00,
  /*  63 */ 0x00, 0x3e, 0x63, 0x60, 0x30, 0x30, 0x18, 0x18, 0x00, 0x18, 0x18, 0x00, 0x00, 0x00,
  /*  64 */ 0x00, 0x3c, 0x66, 0x73, 0x7b, 0x6b, 0x6b, 0x7b, 0x33, 0x06, 0x3c, 0x00, 0x00, 0x00,
  /*  65 */ 0x00, 0x3e, 0x63, 0x63, 0x63, 0x7f, 0x63, 0x63, 0x63, 0x63, 0x63, 0x00, 0x00, 0x00,
  /*  66 */ 0x00, 0x3f, 0x63, 0x63, 0x63, 0x3f, 0x63, 0x63, 0x63, 0x63, 0x3f, 0x00, 0x00, 0x00,
  /*  67 */ 0x00, 0x3c, 0x66, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x66, 0x3c, 0x00, 0x00, 0x00,
  /*  68 */ 0x00, 0x1f, 0x33, 0x63, 0x63, 0x63, 0x63, 0x63, 0x63, 0x33, 0x1f, 0x00, 0x00, 0x00,
  /*  69 */ 0x00, 0x7f, 0x03, 0x03, 0x03, 0x3f, 0x03, 0x03, 0x03, 0x03, 0x7f, 0x00, 0x00, 0x00,
  /*  70 */ 0x00, 0x7f, 0x03, 0x03, 0x03, 0x3f, 0x03, 0x03, 0x03, 0x03, 0x03, 0x00, 0x00, 0x00,
  /*  71 */ 0x00, 0x3c, 0x66, 0x03, 0x03, 0x03, 0x73, 0x63, 0x63, 0x66, 0x7c, 0x00, 0x00, 0x00,
  /*  72 */ 0x00, 0x63, 0x63, 0x63, 0x63, 0x7f, 0x63, 0x63, 0x63, 0x63, 0x63, 0x00, 0x00, 0x00,
  /*  73 */ 0x00, 0x3c, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x3c, 0x00, 0x00, 0x00,
  /*  74 */ 0x00, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x33, 0x1e, 0x00, 0x00, 0x00,
  /*  75 */ 0x00, 0x63, 0x33, 0x1b, 0x0f, 0x07, 0x07, 0x0f, 0x1b, 0x33, 0x63, 0x00, 0x00, 0x00,
  /*  76 */ 0x00, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x7f, 0x00, 0x00, 0x00,
  /*  77 */ 0x00, 0x63, 0x63, 0x77, 0x7f, 0x7f, 0x6b, 0x6b, 0x63, 0x63, 0x63, 0x00, 0x00, 0x00,
  /*  78 */ 0x00, 0x63, 0x63, 0x67, 0x6f, 0x6f, 0x7b, 0x7b, 0x73, 0x63, 0x63, 0x00, 0x00, 0x00,
  /*  79 */ 0x00, 0x3e, 0x63, 0x63, 0x63, 0x63, 0x63, 0x63, 0x63, 0x63, 0x3e, 0x00, 0x00, 0x00,
  /*  80 */ 0x00, 0x3f, 0x63, 0x63, 0x63, 0x63, 0x3f, 0x03, 0x03, 0x03, 0x03, 0x00, 0x00, 0x00,
  /*  81 */ 0x00, 0x3e, 0x63, 0x63, 0x63, 0x63, 0x63, 0x63, 0x6f, 0x7b, 0x3e, 0x30, 0x60, 0x00,
  /*  82 */ 0x00, 0x3f, 0x63, 0x63, 0x63, 0x63, 0x3f, 0x1b, 0x33, 0x63, 0x63, 0x00, 0x00, 0x00,
  /*  83 */ 0x00, 0x3e, 0x63, 0x03, 0x03, 0x0e, 0x38, 0x60, 0x60, 0x63, 0x3e, 0x00, 0x00, 0x00,
  /*  84 */ 0x00, 0x7e, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x00, 0x00, 0x00,
  /*  85 */ 0x00, 0x63, 0x63, 0x63, 0x63, 0x63, 0x63, 0x63, 0x63, 0x63, 0x3e, 0x00, 0x00, 0x00,
  /*  86 */ 0x00, 0x63, 0x63, 0x63, 0x63, 0x63, 0x36, 0x36, 0x1c, 0x1c, 0x08, 0x00, 0x00, 0x00,
  /*  87 */ 0x00, 0x63, 0x63, 0x6b, 0x6b, 0x6b, 0x6b, 0x7f, 0x36, 0x36, 0x36, 0x00, 0x00, 0x00,
  /*  88 */ 0x00, 0x63, 0x63, 0x36, 0x36, 0x1c, 0x1c, 0x36, 0x36, 0x63, 0x63, 0x00, 0x00, 0x00,
  /*  89 */ 0x00, 0xc3, 0xc3, 0x66, 0x66, 0x3c, 0x3c, 0x18, 0x18, 0x18, 0x18, 0x00, 0x00, 0x00,
  /*  90 */ 0x00, 0x7f, 0x30, 0x30, 0x18, 0x18, 0x0c, 0x0c, 0x06, 0x06, 0x7f, 0x00, 0x00, 0x00,
  /*  91 */ 0x00, 0x3c, 0x0c, 0x0c, 0x0c, 0x0c, 0x0c, 0x0c, 0x0c, 0x0c, 0x3c, 0x00, 0x00, 0x00,
  /*  92 */ 0x00, 0x03, 0x02, 0x06, 0x04, 0x0c, 0x08, 0x18, 0x10, 0x30, 0x20, 0x60, 0x00, 0x00,
  /*  93 */ 0x00, 0x3c, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x3c, 0x00, 0x00, 0x00,
  /*  94 */ 0x08, 0x1c, 0x36, 0x63, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  /*  95 */ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0x00,
  /*  96 */ 0x00, 0x0c, 0x0c, 0x18, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  /*  97 */ 0x00, 0x00, 0x00, 0x00, 0x3e, 0x60, 0x7e, 0x63, 0x63, 0x73, 0x6e, 0x00, 0x00, 0x00,
  /*  98 */ 0x00, 0x03, 0x03, 0x03, 0x3b, 0x67, 0x63, 0x63, 0x63, 0x67, 0x3b, 0x00, 0x00, 0x00,
  /*  99 */ 0x00, 0x00, 0x00, 0x00, 0x3e, 0x63, 0x03, 0x03, 0x03, 0x63, 0x3e, 0x00, 0x00, 0x00,
  /* 100 */ 0x00, 0x60, 0x60, 0x60, 0x6e, 0x73, 0x63, 0x63, 0x63, 0x73, 0x6e, 0x00, 0x00, 0x00,
  /* 101 */ 0x00, 0x00, 0x00, 0x00, 0x3e, 0x63, 0x63, 0x7f, 0x03, 0x63, 0x3e, 0x00, 0x00, 0x00,
  /* 102 */ 0x00, 0x3c, 0x66, 0x06, 0x1f, 0x06, 0x06, 0x06, 0x06, 0x06, 0x06, 0x00, 0x00, 0x00,
  /* 103 */ 0x00, 0x00, 0x00, 0x00, 0x6e, 0x73, 0x63, 0x63, 0x63, 0x73, 0x6e, 0x60, 0x63, 0x3e,
  /* 104 */ 0x00, 0x03, 0x03, 0x03, 0x3b, 0x67, 0x63, 0x63, 0x63, 0x63, 0x63, 0x00, 0x00, 0x00,
  /* 105 */ 0x00, 0x0c, 0x0c, 0x00, 0x0c, 0x0c, 0x0c, 0x0c, 0x0c, 0x0c, 0x38, 0x00, 0x00, 0x00,
  /* 106 */ 0x00, 0x30, 0x30, 0x00, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x33, 0x1e,
  /* 107 */ 0x00, 0x03, 0x03, 0x03, 0x63, 0x33, 0x1b, 0x0f, 0x1f, 0x33, 0x63, 0x00, 0x00, 0x00,
  /* 108 */ 0x00, 0x0c, 0x0c, 0x0c, 0x0c, 0x0c, 0x0c, 0x0c, 0x0c, 0x0c, 0x38, 0x00, 0x00, 0x00,
  /* 109 */ 0x00, 0x00, 0x00, 0x00, 0x35, 0x6b, 0x6b, 0x6b, 0x6b, 0x6b, 0x6b, 0x00, 0x00, 0x00,
  /* 110 */ 0x00, 0x00, 0x00, 0x00, 0x3b, 0x67, 0x63, 0x63, 0x63, 0x63, 0x63, 0x00, 0x00, 0x00,
  /* 111 */ 0x00, 0x00, 0x00, 0x00, 0x3e, 0x63, 0x63, 0x63, 0x63, 0x63, 0x3e, 0x00, 0x00, 0x00,
  /* 112 */ 0x00, 0x00, 0x00, 0x00, 0x3b, 0x67, 0x63, 0x63, 0x63, 0x67, 0x3b, 0x03, 0x03, 0x03,
  /* 113 */ 0x00, 0x00, 0x00, 0x00, 0x6e, 0x73, 0x63, 0x63, 0x63, 0x73, 0x6e, 0x60, 0xe0, 0x60,
  /* 114 */ 0x00, 0x00, 0x00, 0x00, 0x3b, 0x67, 0x03, 0x03, 0x03, 0x03, 0x03, 0x00, 0x00, 0x00,
  /* 115 */ 0x00, 0x00, 0x00, 0x00, 0x3e, 0x63, 0x0e, 0x38, 0x60, 0x63, 0x3e, 0x00, 0x00, 0x00,
  /* 116 */ 0x00, 0x00, 0x0c, 0x0c, 0x3e, 0x0c, 0x0c, 0x0c, 0x0c, 0x0c, 0x38, 0x00, 0x00, 0x00,
  /* 117 */ 0x00, 0x00, 0x00, 0x00, 0x63, 0x63, 0x63, 0x63, 0x63, 0x73, 0x6e, 0x00, 0x00, 0x00,
  /* 118 */ 0x00, 0x00, 0x00, 0x00, 0x63, 0x63, 0x36, 0x36, 0x1c, 0x1c, 0x08, 0x00, 0x00, 0x00,
  /* 119 */ 0x00, 0x00, 0x00, 0x00, 0x63, 0x6b, 0x6b, 0x6b, 0x3e, 0x36, 0x36, 0x00, 0x00, 0x00,
  /* 120 */ 0x00, 0x00, 0x00, 0x00, 0x63, 0x36, 0x1c, 0x1c, 0x1c, 0x36, 0x63, 0x00, 0x00, 0x00,
  /* 121 */ 0x00, 0x00, 0x00, 0x00, 0x63, 0x63, 0x36, 0x36, 0x1c, 0x1c, 0x0c, 0x0c, 0x06, 0x03,
  /* 122 */ 0x00, 0x00, 0x00, 0x00, 0x7f, 0x60, 0x30, 0x18, 0x0c, 0x06, 0x7f, 0x00, 0x00, 0x00,
  /* 123 */ 0x00, 0x70, 0x18, 0x18, 0x18, 0x18, 0x0e, 0x18, 0x18, 0x18, 0x18, 0x70, 0x00, 0x00,
  /* 124 */ 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x00, 0x00,
  /* 125 */ 0x00, 0x0e, 0x18, 0x18, 0x18, 0x18, 0x70, 0x18, 0x18, 0x18, 0x18, 0x0e, 0x00, 0x00,
  /* 126 */ 0x00, 0x00, 0x00, 0x00, 0x00, 0x6e, 0x3b, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
};

/*
 * Second page of ISO Latin-1 font.
 */
#define PAGE1_CHAR_MIN   (161 - 0x80)
#define PAGE1_CHAR_MAX   (256 - 0x80)
#define PAGE1_FONT_HEAD  (0)
#define PAGE1_FONT_TAIL  (1)

STATIC UINT8  mIsoFontDataPage1[(PAGE1_CHAR_MAX - PAGE1_CHAR_MIN) * (ISO_CHAR_HEIGHT - PAGE1_FONT_HEAD - PAGE1_FONT_TAIL)] = {
  /* 161 */ 0x00, 0x00, 0x00, 0x00, 0x18, 0x18, 0x00, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x00,
  /* 162 */ 0x00, 0x00, 0x00, 0x08, 0x08, 0x3e, 0x6b, 0x0b, 0x0b, 0x0b, 0x6b, 0x3e, 0x08, 0x08, 0x00,
  /* 163 */ 0x00, 0x00, 0x1c, 0x36, 0x06, 0x06, 0x1f, 0x06, 0x06, 0x07, 0x6f, 0x3b, 0x00, 0x00, 0x00,
  /* 164 */ 0x00, 0x00, 0x00, 0x00, 0x66, 0x3c, 0x66, 0x66, 0x66, 0x3c, 0x66, 0x00, 0x00, 0x00, 0x00,
  /* 165 */ 0x00, 0x00, 0xc3, 0xc3, 0x66, 0x66, 0x3c, 0x7e, 0x18, 0x7e, 0x18, 0x18, 0x00, 0x00, 0x00,
  /* 166 */ 0x00, 0x00, 0x18, 0x18, 0x18, 0x18, 0x00, 0x00, 0x18, 0x18, 0x18, 0x18, 0x00, 0x00, 0x00,
  /* 167 */ 0x00, 0x3c, 0x66, 0x0c, 0x1e, 0x33, 0x63, 0x66, 0x3c, 0x18, 0x33, 0x1e, 0x00, 0x00, 0x00,
  /* 168 */ 0x00, 0x00, 0x36, 0x36, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  /* 169 */ 0x00, 0x00, 0x3c, 0x42, 0x99, 0xa5, 0x85, 0xa5, 0x99, 0x42, 0x3c, 0x00, 0x00, 0x00, 0x00,
  /* 170 */ 0x00, 0x1e, 0x30, 0x3e, 0x33, 0x3b, 0x36, 0x00, 0x3f, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  /* 171 */ 0x00, 0x00, 0x00, 0x00, 0x00, 0x6c, 0x36, 0x1b, 0x1b, 0x36, 0x6c, 0x00, 0x00, 0x00, 0x00,
  /* 172 */ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x7f, 0x60, 0x60, 0x60, 0x00, 0x00, 0x00, 0x00, 0x00,
  /* 173 */ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x3c, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  /* 174 */ 0x00, 0x00, 0x3c, 0x42, 0x9d, 0xa5, 0x9d, 0xa5, 0xa5, 0x42, 0x3c, 0x00, 0x00, 0x00, 0x00,
  /* 175 */ 0x00, 0x7e, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  /* 176 */ 0x00, 0x00, 0x1c, 0x36, 0x36, 0x1c, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  /* 177 */ 0x00, 0x00, 0x00, 0x00, 0x18, 0x18, 0x7e, 0x18, 0x18, 0x00, 0x7e, 0x00, 0x00, 0x00, 0x00,
  /* 178 */ 0x00, 0x1e, 0x33, 0x18, 0x0c, 0x06, 0x3f, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  /* 179 */ 0x00, 0x1e, 0x33, 0x18, 0x30, 0x33, 0x1e, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  /* 180 */ 0x00, 0x30, 0x18, 0x0c, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  /* 181 */ 0x00, 0x00, 0x00, 0x00, 0x00, 0x66, 0x66, 0x66, 0x66, 0x66, 0x76, 0x6e, 0x06, 0x06, 0x03,
  /* 182 */ 0x00, 0x00, 0x7e, 0x2f, 0x2f, 0x2f, 0x2e, 0x28, 0x28, 0x28, 0x28, 0x28, 0x00, 0x00, 0x00,
  /* 183 */ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x18, 0x18, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  /* 184 */ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x18, 0x30, 0x1e,
  /* 185 */ 0x00, 0x0c, 0x0e, 0x0c, 0x0c, 0x0c, 0x1e, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  /* 186 */ 0x00, 0x1e, 0x33, 0x33, 0x33, 0x33, 0x1e, 0x00, 0x3f, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  /* 187 */ 0x00, 0x00, 0x00, 0x00, 0x00, 0x1b, 0x36, 0x6c, 0x6c, 0x36, 0x1b, 0x00, 0x00, 0x00, 0x00,
  /* 188 */ 0x00, 0x10, 0x1c, 0x18, 0x18, 0x18, 0x00, 0x7f, 0x00, 0x18, 0x1c, 0x1a, 0x3e, 0x18, 0x00,
  /* 189 */ 0x00, 0x10, 0x1c, 0x18, 0x18, 0x18, 0x00, 0x7f, 0x00, 0x1c, 0x36, 0x18, 0x0c, 0x3e, 0x00,
  /* 190 */ 0x00, 0x1c, 0x36, 0x18, 0x36, 0x1c, 0x00, 0x7f, 0x00, 0x18, 0x1c, 0x1a, 0x3e, 0x18, 0x00,
  /* 191 */ 0x00, 0x00, 0x00, 0x00, 0x0c, 0x0c, 0x00, 0x0c, 0x0c, 0x06, 0x06, 0x03, 0x63, 0x3e, 0x00,
  /* 192 */ 0x0c, 0x18, 0x3e, 0x63, 0x63, 0x63, 0x7f, 0x63, 0x63, 0x63, 0x63, 0x63, 0x00, 0x00, 0x00,
  /* 193 */ 0x18, 0x0c, 0x3e, 0x63, 0x63, 0x63, 0x7f, 0x63, 0x63, 0x63, 0x63, 0x63, 0x00, 0x00, 0x00,
  /* 194 */ 0x08, 0x14, 0x3e, 0x63, 0x63, 0x63, 0x7f, 0x63, 0x63, 0x63, 0x63, 0x63, 0x00, 0x00, 0x00,
  /* 195 */ 0x6e, 0x3b, 0x3e, 0x63, 0x63, 0x63, 0x7f, 0x63, 0x63, 0x63, 0x63, 0x63, 0x00, 0x00, 0x00,
  /* 196 */ 0x36, 0x00, 0x3e, 0x63, 0x63, 0x63, 0x7f, 0x63, 0x63, 0x63, 0x63, 0x63, 0x00, 0x00, 0x00,
  /* 197 */ 0x1c, 0x36, 0x3e, 0x63, 0x63, 0x63, 0x7f, 0x63, 0x63, 0x63, 0x63, 0x63, 0x00, 0x00, 0x00,
  /* 198 */ 0x00, 0x00, 0xfe, 0x33, 0x33, 0x33, 0xff, 0x33, 0x33, 0x33, 0x33, 0xf3, 0x00, 0x00, 0x00,
  /* 199 */ 0x00, 0x00, 0x3c, 0x66, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x66, 0x3c, 0x18, 0x30, 0x1e,
  /* 200 */ 0x0c, 0x18, 0x7f, 0x03, 0x03, 0x03, 0x3f, 0x03, 0x03, 0x03, 0x03, 0x7f, 0x00, 0x00, 0x00,
  /* 201 */ 0x18, 0x0c, 0x7f, 0x03, 0x03, 0x03, 0x3f, 0x03, 0x03, 0x03, 0x03, 0x7f, 0x00, 0x00, 0x00,
  /* 202 */ 0x08, 0x14, 0x7f, 0x03, 0x03, 0x03, 0x3f, 0x03, 0x03, 0x03, 0x03, 0x7f, 0x00, 0x00, 0x00,
  /* 203 */ 0x36, 0x00, 0x7f, 0x03, 0x03, 0x03, 0x3f, 0x03, 0x03, 0x03, 0x03, 0x7f, 0x00, 0x00, 0x00,
  /* 204 */ 0x0c, 0x18, 0x3c, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x3c, 0x00, 0x00, 0x00,
  /* 205 */ 0x30, 0x18, 0x3c, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x3c, 0x00, 0x00, 0x00,
  /* 206 */ 0x18, 0x24, 0x3c, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x3c, 0x00, 0x00, 0x00,
  /* 207 */ 0x66, 0x00, 0x3c, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x3c, 0x00, 0x00, 0x00,
  /* 208 */ 0x00, 0x00, 0x1e, 0x36, 0x66, 0x66, 0x6f, 0x66, 0x66, 0x66, 0x36, 0x1e, 0x00, 0x00, 0x00,
  /* 209 */ 0x6e, 0x3b, 0x63, 0x63, 0x67, 0x6f, 0x6f, 0x7b, 0x7b, 0x73, 0x63, 0x63, 0x00, 0x00, 0x00,
  /* 210 */ 0x06, 0x0c, 0x3e, 0x63, 0x63, 0x63, 0x63, 0x63, 0x63, 0x63, 0x63, 0x3e, 0x00, 0x00, 0x00,
  /* 211 */ 0x30, 0x18, 0x3e, 0x63, 0x63, 0x63, 0x63, 0x63, 0x63, 0x63, 0x63, 0x3e, 0x00, 0x00, 0x00,
  /* 212 */ 0x08, 0x14, 0x3e, 0x63, 0x63, 0x63, 0x63, 0x63, 0x63, 0x63, 0x63, 0x3e, 0x00, 0x00, 0x00,
  /* 213 */ 0x6e, 0x3b, 0x3e, 0x63, 0x63, 0x63, 0x63, 0x63, 0x63, 0x63, 0x63, 0x3e, 0x00, 0x00, 0x00,
  /* 214 */ 0x36, 0x00, 0x3e, 0x63, 0x63, 0x63, 0x63, 0x63, 0x63, 0x63, 0x63, 0x3e, 0x00, 0x00, 0x00,
  /* 215 */ 0x00, 0x00, 0x00, 0x00, 0x00, 0x66, 0x3c, 0x18, 0x3c, 0x66, 0x00, 0x00, 0x00, 0x00, 0x00,
  /* 216 */ 0x00, 0x20, 0x3e, 0x73, 0x73, 0x6b, 0x6b, 0x6b, 0x6b, 0x67, 0x67, 0x3e, 0x02, 0x00, 0x00,
  /* 217 */ 0x0c, 0x18, 0x63, 0x63, 0x63, 0x63, 0x63, 0x63, 0x63, 0x63, 0x63, 0x3e, 0x00, 0x00, 0x00,
  /* 218 */ 0x18, 0x0c, 0x63, 0x63, 0x63, 0x63, 0x63, 0x63, 0x63, 0x63, 0x63, 0x3e, 0x00, 0x00, 0x00,
  /* 219 */ 0x08, 0x14, 0x63, 0x63, 0x63, 0x63, 0x63, 0x63, 0x63, 0x63, 0x63, 0x3e, 0x00, 0x00, 0x00,
  /* 220 */ 0x36, 0x00, 0x63, 0x63, 0x63, 0x63, 0x63, 0x63, 0x63, 0x63, 0x63, 0x3e, 0x00, 0x00, 0x00,
  /* 221 */ 0x30, 0x18, 0xc3, 0xc3, 0x66, 0x66, 0x3c, 0x3c, 0x18, 0x18, 0x18, 0x18, 0x00, 0x00, 0x00,
  /* 222 */ 0x00, 0x00, 0x0f, 0x06, 0x3e, 0x66, 0x66, 0x66, 0x66, 0x3e, 0x06, 0x0f, 0x00, 0x00, 0x00,
  /* 223 */ 0x00, 0x00, 0x1e, 0x33, 0x33, 0x1b, 0x33, 0x63, 0x63, 0x63, 0x63, 0x3b, 0x00, 0x00, 0x00,
  /* 224 */ 0x00, 0x0c, 0x18, 0x30, 0x00, 0x3e, 0x60, 0x7e, 0x63, 0x63, 0x73, 0x6e, 0x00, 0x00, 0x00,
  /* 225 */ 0x00, 0x30, 0x18, 0x0c, 0x00, 0x3e, 0x60, 0x7e, 0x63, 0x63, 0x73, 0x6e, 0x00, 0x00, 0x00,
  /* 226 */ 0x00, 0x08, 0x1c, 0x36, 0x00, 0x3e, 0x60, 0x7e, 0x63, 0x63, 0x73, 0x6e, 0x00, 0x00, 0x00,
  /* 227 */ 0x00, 0x00, 0x6e, 0x3b, 0x00, 0x3e, 0x60, 0x7e, 0x63, 0x63, 0x73, 0x6e, 0x00, 0x00, 0x00,
  /* 228 */ 0x00, 0x00, 0x36, 0x36, 0x00, 0x3e, 0x60, 0x7e, 0x63, 0x63, 0x73, 0x6e, 0x00, 0x00, 0x00,
  /* 229 */ 0x00, 0x1c, 0x36, 0x1c, 0x00, 0x3e, 0x60, 0x7e, 0x63, 0x63, 0x73, 0x6e, 0x00, 0x00, 0x00,
  /* 230 */ 0x00, 0x00, 0x00, 0x00, 0x00, 0x6e, 0xdb, 0xd8, 0xfe, 0x1b, 0xdb, 0x76, 0x00, 0x00, 0x00,
  /* 231 */ 0x00, 0x00, 0x00, 0x00, 0x00, 0x3e, 0x63, 0x03, 0x03, 0x03, 0x63, 0x3e, 0x18, 0x30, 0x1e,
  /* 232 */ 0x00, 0x0c, 0x18, 0x30, 0x00, 0x3e, 0x63, 0x63, 0x7f, 0x03, 0x63, 0x3e, 0x00, 0x00, 0x00,
  /* 233 */ 0x00, 0x30, 0x18, 0x0c, 0x00, 0x3e, 0x63, 0x63, 0x7f, 0x03, 0x63, 0x3e, 0x00, 0x00, 0x00,
  /* 234 */ 0x00, 0x08, 0x1c, 0x36, 0x00, 0x3e, 0x63, 0x63, 0x7f, 0x03, 0x63, 0x3e, 0x00, 0x00, 0x00,
  /* 235 */ 0x00, 0x00, 0x36, 0x36, 0x00, 0x3e, 0x63, 0x63, 0x7f, 0x03, 0x63, 0x3e, 0x00, 0x00, 0x00,
  /* 236 */ 0x00, 0x06, 0x0c, 0x18, 0x00, 0x0c, 0x0c, 0x0c, 0x0c, 0x0c, 0x0c, 0x38, 0x00, 0x00, 0x00,
  /* 237 */ 0x00, 0x18, 0x0c, 0x06, 0x00, 0x0c, 0x0c, 0x0c, 0x0c, 0x0c, 0x0c, 0x38, 0x00, 0x00, 0x00,
  /* 238 */ 0x00, 0x08, 0x1c, 0x36, 0x00, 0x0c, 0x0c, 0x0c, 0x0c, 0x0c, 0x0c, 0x38, 0x00, 0x00, 0x00,
  /* 239 */ 0x00, 0x00, 0x36, 0x36, 0x00, 0x0c, 0x0c, 0x0c, 0x0c, 0x0c, 0x0c, 0x38, 0x00, 0x00, 0x00,
  /* 240 */ 0x00, 0x00, 0x2c, 0x18, 0x34, 0x60, 0x7c, 0x66, 0x66, 0x66, 0x66, 0x3c, 0x00, 0x00, 0x00,
  /* 241 */ 0x00, 0x00, 0x6e, 0x3b, 0x00, 0x3b, 0x67, 0x63, 0x63, 0x63, 0x63, 0x63, 0x00, 0x00, 0x00,
  /* 242 */ 0x00, 0x06, 0x0c, 0x18, 0x00, 0x3e, 0x63, 0x63, 0x63, 0x63, 0x63, 0x3e, 0x00, 0x00, 0x00,
  /* 243 */ 0x00, 0x30, 0x18, 0x0c, 0x00, 0x3e, 0x63, 0x63, 0x63, 0x63, 0x63, 0x3e, 0x00, 0x00, 0x00,
  /* 244 */ 0x00, 0x08, 0x1c, 0x36, 0x00, 0x3e, 0x63, 0x63, 0x63, 0x63, 0x63, 0x3e, 0x00, 0x00, 0x00,
  /* 245 */ 0x00, 0x00, 0x6e, 0x3b, 0x00, 0x3e, 0x63, 0x63, 0x63, 0x63, 0x63, 0x3e, 0x00, 0x00, 0x00,
  /* 246 */ 0x00, 0x00, 0x36, 0x36, 0x00, 0x3e, 0x63, 0x63, 0x63, 0x63, 0x63, 0x3e, 0x00, 0x00, 0x00,
  /* 247 */ 0x00, 0x00, 0x00, 0x00, 0x18, 0x18, 0x00, 0x7e, 0x00, 0x18, 0x18, 0x00, 0x00, 0x00, 0x00,
  /* 248 */ 0x00, 0x00, 0x00, 0x00, 0x20, 0x3e, 0x73, 0x6b, 0x6b, 0x6b, 0x67, 0x3e, 0x02, 0x00, 0x00,
  /* 249 */ 0x00, 0x06, 0x0c, 0x18, 0x00, 0x63, 0x63, 0x63, 0x63, 0x63, 0x73, 0x6e, 0x00, 0x00, 0x00,
  /* 250 */ 0x00, 0x30, 0x18, 0x0c, 0x00, 0x63, 0x63, 0x63, 0x63, 0x63, 0x73, 0x6e, 0x00, 0x00, 0x00,
  /* 251 */ 0x00, 0x08, 0x1c, 0x36, 0x00, 0x63, 0x63, 0x63, 0x63, 0x63, 0x73, 0x6e, 0x00, 0x00, 0x00,
  /* 252 */ 0x00, 0x00, 0x36, 0x36, 0x00, 0x63, 0x63, 0x63, 0x63, 0x63, 0x73, 0x6e, 0x00, 0x00, 0x00,
  /* 253 */ 0x00, 0x30, 0x18, 0x0c, 0x00, 0x63, 0x63, 0x36, 0x36, 0x1c, 0x1c, 0x0c, 0x0c, 0x06, 0x03,
  /* 254 */ 0x00, 0x00, 0x0f, 0x06, 0x06, 0x3e, 0x66, 0x66, 0x66, 0x66, 0x66, 0x3e, 0x06, 0x06, 0x0f,
  /* 255 */ 0x00, 0x00, 0x36, 0x36, 0x00, 0x63, 0x63, 0x36, 0x36, 0x1c, 0x1c, 0x0c, 0x0c, 0x06, 0x03
};

/*
 * Unicode box drawing and block element characters (used e.g. by memtest86).
 * Unicode font pages derived from https://github.com/farsil/ibmfonts
 * SPDX-License-Identifier: CC-BY-SA-4.0
 * (Exported as hex using `gbdfed` from ib8x16u.bdf, sparse info generated with `head`, `tail`, `nl` and additional hand editing.)
 */
#define ADDITIONAL_FONT_PAGE_MIN  (74)
#define ADDITIONAL_FONT_PAGE_MAX  (76)

#define PAGE74_CHAR_MIN           (0x00)
#define PAGE74_CHAR_MAX           (0x6D)
#define PAGE74_SPARSE_CHAR_COUNT  (40)

STATIC UINT8  mGlyphsPage74[PAGE74_SPARSE_CHAR_COUNT * ISO_CHAR_HEIGHT] = {
  /* 0x2500 */ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xFF, 0xFF, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  /* 0x2502 */ 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18,
  /* 0x250C */ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x1F, 0x1F, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18,
  /* 0x2510 */ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xF8, 0xF8, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18,
  /* 0x2514 */ 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x1F, 0x1F, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  /* 0x2518 */ 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0xF8, 0xF8, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  /* 0x251C */ 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x1F, 0x1F, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18,
  /* 0x2524 */ 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0xF8, 0xF8, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18,
  /* 0x252C */ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xFF, 0xFF, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18,
  /* 0x2534 */ 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0xFF, 0xFF, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  /* 0x253C */ 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0xFF, 0xFF, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18,
  /* 0x2550 */ 0x00, 0x00, 0x00, 0x00, 0xFF, 0xFF, 0x00, 0x00, 0xFF, 0xFF, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  /* 0x2551 */ 0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36,
  /* 0x2552 */ 0x00, 0x00, 0x00, 0x00, 0x1F, 0x1F, 0x18, 0x18, 0x1F, 0x1F, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18,
  /* 0x2553 */ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x3F, 0x3F, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36,
  /* 0x2554 */ 0x00, 0x00, 0x00, 0x00, 0x3F, 0x3F, 0x30, 0x30, 0x37, 0x37, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36,
  /* 0x2555 */ 0x00, 0x00, 0x00, 0x00, 0xF8, 0xF8, 0x18, 0x18, 0xF8, 0xF8, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18,
  /* 0x2556 */ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xFE, 0xFE, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36,
  /* 0x2557 */ 0x00, 0x00, 0x00, 0x00, 0xFE, 0xFE, 0x06, 0x06, 0xF6, 0xF6, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36,
  /* 0x2558 */ 0x18, 0x18, 0x18, 0x18, 0x1F, 0x1F, 0x18, 0x18, 0x1F, 0x1F, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  /* 0x2559 */ 0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x3F, 0x3F, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  /* 0x255A */ 0x36, 0x36, 0x36, 0x36, 0x37, 0x37, 0x30, 0x30, 0x3F, 0x3F, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  /* 0x255B */ 0x18, 0x18, 0x18, 0x18, 0xF8, 0xF8, 0x18, 0x18, 0xF8, 0xF8, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  /* 0x255C */ 0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0xFE, 0xFE, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  /* 0x255D */ 0x36, 0x36, 0x36, 0x36, 0xF6, 0xF6, 0x06, 0x06, 0xFE, 0xFE, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  /* 0x255E */ 0x18, 0x18, 0x18, 0x18, 0x1F, 0x1F, 0x18, 0x18, 0x1F, 0x1F, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18,
  /* 0x255F */ 0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x37, 0x37, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36,
  /* 0x2560 */ 0x36, 0x36, 0x36, 0x36, 0x37, 0x37, 0x30, 0x30, 0x37, 0x37, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36,
  /* 0x2561 */ 0x18, 0x18, 0x18, 0x18, 0xF8, 0xF8, 0x18, 0x18, 0xF8, 0xF8, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18,
  /* 0x2562 */ 0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0xF6, 0xF6, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36,
  /* 0x2563 */ 0x36, 0x36, 0x36, 0x36, 0xF6, 0xF6, 0x06, 0x06, 0xF6, 0xF6, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36,
  /* 0x2564 */ 0x00, 0x00, 0x00, 0x00, 0xFF, 0xFF, 0x00, 0x00, 0xFF, 0xFF, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18,
  /* 0x2565 */ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xFF, 0xFF, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36,
  /* 0x2566 */ 0x00, 0x00, 0x00, 0x00, 0xFF, 0xFF, 0x00, 0x00, 0xF7, 0xF7, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36,
  /* 0x2567 */ 0x18, 0x18, 0x18, 0x18, 0xFF, 0xFF, 0x00, 0x00, 0xFF, 0xFF, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  /* 0x2568 */ 0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0xFF, 0xFF, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  /* 0x2569 */ 0x36, 0x36, 0x36, 0x36, 0xF7, 0xF7, 0x00, 0x00, 0xFF, 0xFF, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  /* 0x256A */ 0x18, 0x18, 0x18, 0x18, 0xFF, 0xFF, 0x18, 0x18, 0xFF, 0xFF, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18,
  /* 0x256B */ 0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0xFF, 0xFF, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36,
  /* 0x256C */ 0x36, 0x36, 0x36, 0x36, 0xF7, 0xF7, 0x00, 0x00, 0xF7, 0xF7, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36
};

STATIC UINT8  mOffsetsPage74[PAGE74_CHAR_MAX - PAGE74_CHAR_MIN] = {
  1,    /* 0x2500 */
  0,
  2,    /* 0x2502 */
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  3,    /* 0x250C */
  0,
  0,
  0,
  4,    /* 0x2510 */
  0,
  0,
  0,
  5,    /* 0x2514 */
  0,
  0,
  0,
  6,    /* 0x2518 */
  0,
  0,
  0,
  7,    /* 0x251C */
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  8,    /* 0x2524 */
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  9,    /* 0x252C */
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  10,   /* 0x2534 */
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  11,   /* 0x253C */
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  12,   /* 0x2550 */
  13,   /* 0x2551 */
  14,   /* 0x2552 */
  15,   /* 0x2553 */
  16,   /* 0x2554 */
  17,   /* 0x2555 */
  18,   /* 0x2556 */
  19,   /* 0x2557 */
  20,   /* 0x2558 */
  21,   /* 0x2559 */
  22,   /* 0x255A */
  23,   /* 0x255B */
  24,   /* 0x255C */
  25,   /* 0x255D */
  26,   /* 0x255E */
  27,   /* 0x255F */
  28,   /* 0x2560 */
  29,   /* 0x2561 */
  30,   /* 0x2562 */
  31,   /* 0x2563 */
  32,   /* 0x2564 */
  33,   /* 0x2565 */
  34,   /* 0x2566 */
  35,   /* 0x2567 */
  36,   /* 0x2568 */
  37,   /* 0x2569 */
  38,   /* 0x256A */
  39,   /* 0x256B */
  40    /* 0x256C */
};

#define PAGE75_CHAR_MIN           (0x00)
#define PAGE75_CHAR_MAX           (0xE7)
#define PAGE75_SPARSE_CHAR_COUNT  (24)

STATIC UINT8  mGlyphsPage75[PAGE75_SPARSE_CHAR_COUNT * ISO_CHAR_HEIGHT] = {
  /* 0x2580 */ 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  /* 0x2581 */ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xFF, 0xFF, 0xFF, 0xFF,
  /* 0x2584 */ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
  /* 0x2588 */ 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
  /* 0x258C */ 0xF0, 0xF0, 0xF0, 0xF0, 0xF0, 0xF0, 0xF0, 0xF0, 0xF0, 0xF0, 0xF0, 0xF0, 0xF0, 0xF0, 0xF0, 0xF0,
  /* 0x2590 */ 0x0F, 0x0F, 0x0F, 0x0F, 0x0F, 0x0F, 0x0F, 0x0F, 0x0F, 0x0F, 0x0F, 0x0F, 0x0F, 0x0F, 0x0F, 0x0F,
  /* 0x2591 */ 0x22, 0x22, 0x88, 0x88, 0x22, 0x22, 0x88, 0x88, 0x22, 0x22, 0x88, 0x88, 0x22, 0x22, 0x88, 0x88,
  /* 0x2592 */ 0x55, 0x55, 0xAA, 0xAA, 0x55, 0x55, 0xAA, 0xAA, 0x55, 0x55, 0xAA, 0xAA, 0x55, 0x55, 0xAA, 0xAA,
  /* 0x2593 */ 0xDB, 0xDB, 0x77, 0x77, 0xDB, 0xDB, 0xEE, 0xEE, 0xDB, 0xDB, 0x77, 0x77, 0xDB, 0xDB, 0xEE, 0xEE,
  /* 0x25A0 */ 0x00, 0x00, 0x00, 0x00, 0x3C, 0x3C, 0x3C, 0x3C, 0x3C, 0x3C, 0x3C, 0x3C, 0x00, 0x00, 0x00, 0x00,
  /* 0x25A1 */ 0x00, 0x00, 0x00, 0x00, 0x7C, 0x7C, 0x6C, 0x6C, 0x6C, 0x6C, 0x7C, 0x7C, 0x00, 0x00, 0x00, 0x00,
  /* 0x25AA */ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x3C, 0x3C, 0x3C, 0x3C, 0x3C, 0x3C, 0x00, 0x00, 0x00, 0x00,
  /* 0x25AB */ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x7C, 0x7C, 0x6C, 0x6C, 0x7C, 0x7C, 0x00, 0x00, 0x00, 0x00,
  /* 0x25AC */ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x7E, 0x7E, 0x7E, 0x7E, 0x7E, 0x7E, 0x00, 0x00,
  /* 0x25B2 */ 0x00, 0x00, 0x18, 0x18, 0x3C, 0x3C, 0x7E, 0x7E, 0xFF, 0xFF, 0xFF, 0xFF, 0x00, 0x00, 0x00, 0x00,
  /* 0x25BA */ 0x80, 0x80, 0xE0, 0xE0, 0xF8, 0xF8, 0xFE, 0xFE, 0xF8, 0xF8, 0xE0, 0xE0, 0x80, 0x80, 0x00, 0x00,
  /* 0x25BC */ 0x00, 0x00, 0xFF, 0xFF, 0xFF, 0xFF, 0x7E, 0x7E, 0x3C, 0x3C, 0x18, 0x18, 0x00, 0x00, 0x00, 0x00,
  /* 0x25C4 */ 0x02, 0x02, 0x0E, 0x0E, 0x3E, 0x3E, 0xFE, 0xFE, 0x3E, 0x3E, 0x0E, 0x0E, 0x02, 0x02, 0x00, 0x00,
  /* 0x25CA */ 0x10, 0x10, 0x38, 0x38, 0x6C, 0x6C, 0xC6, 0xC6, 0x6C, 0x6C, 0x38, 0x38, 0x10, 0x10, 0x00, 0x00,
  /* 0x25CB */ 0x00, 0x00, 0x3C, 0x3C, 0x66, 0x66, 0x42, 0x42, 0x42, 0x42, 0x66, 0x66, 0x3C, 0x3C, 0x00, 0x00,
  /* 0x25CF */ 0x00, 0x00, 0x3C, 0x3C, 0x7E, 0x7E, 0x7E, 0x7E, 0x7E, 0x7E, 0x7E, 0x7E, 0x3C, 0x3C, 0x00, 0x00,
  /* 0x25D8 */ 0xFF, 0xFF, 0xFF, 0xFF, 0xE7, 0xE7, 0xC3, 0xC3, 0xC3, 0xC3, 0xE7, 0xE7, 0xFF, 0xFF, 0xFF, 0xFF,
  /* 0x25D9 */ 0xFF, 0xFF, 0xC3, 0xC3, 0x99, 0x99, 0xBD, 0xBD, 0xBD, 0xBD, 0x99, 0x99, 0xC3, 0xC3, 0xFF, 0xFF,
  /* 0x25E6 */ 0x00, 0x00, 0x00, 0x00, 0x38, 0x38, 0x6C, 0x6C, 0x6C, 0x6C, 0x38, 0x38, 0x00, 0x00, 0x00, 0x00
};

STATIC UINT8  mOffsetsPage75[PAGE75_CHAR_MAX - PAGE75_CHAR_MIN] = {
  1, /* 0x2580 */
  2, /* 0x2581 */
  0,
  0,
  3, /* 0x2584 */
  0,
  0,
  0,
  4, /* 0x2588 */
  0,
  0,
  0,
  5, /* 0x258C */
  0,
  0,
  0,
  6, /* 0x2590 */
  7, /* 0x2591 */
  8, /* 0x2592 */
  9, /* 0x2593 */
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  10, /* 0x25A0 */
  11, /* 0x25A1 */
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  12, /* 0x25AA */
  13, /* 0x25AB */
  14, /* 0x25AC */
  0,
  0,
  0,
  0,
  0,
  15, /* 0x25B2 */
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  16, /* 0x25BA */
  0,
  17, /* 0x25BC */
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  18, /* 0x25C4 */
  0,
  0,
  0,
  0,
  0,
  19, /* 0x25CA */
  20, /* 0x25CB */
  0,
  0,
  0,
  21, /* 0x25CF */
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  22, /* 0x25D8 */
  23, /* 0x25D9 */
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  24  /* 0x25E6 */
};

typedef struct {
  UINT8      *Glyphs;
  UINT8      *Offsets;
  UINT8      Min;
  UINT8      Max;
  BOOLEAN    LeftToRight;
} UNICODE_PAGE;

//
// Specify { NULL, NULL, 0, 0, FALSE } for any non-populated page in range.
//
STATIC UNICODE_PAGE  mUnicodePages[ADDITIONAL_FONT_PAGE_MAX - ADDITIONAL_FONT_PAGE_MIN] = {
  { mGlyphsPage74, mOffsetsPage74, PAGE74_CHAR_MIN, PAGE74_CHAR_MAX, TRUE },
  { mGlyphsPage75, mOffsetsPage75, PAGE75_CHAR_MIN, PAGE75_CHAR_MAX, TRUE }
};

STATIC UINT32  mGraphicsEfiColors[16] = {
  0x00000000,  // BLACK
  0x00000098,  // LIGHTBLUE
  0x00009800,  // LIGHTGREEN
  0x00009898,  // LIGHTCYAN
  0x00980000,  // LIGHTRED
  0x00980098,  // MAGENTA
  0x00989800,  // BROWN
  0x00bfbfbf,  // LIGHTGRAY
  0x00303030,  // DARKGRAY - BRIGHT BLACK
  0x000000ff,  // BLUE
  0x0000ff00,  // LIME
  0x0000ffff,  // CYAN
  0x00ff0000,  // RED
  0x00ff00ff,  // FUCHSIA
  0x00ffff00,  // YELLOW
  0x00ffffff   // WHITE
};

STATIC EFI_GRAPHICS_OUTPUT_PROTOCOL         *mGraphicsOutput;
STATIC UINTN                                mConsolePaddingX;
STATIC UINTN                                mConsolePaddingY;
STATIC UINTN                                mUserWidth;
STATIC UINTN                                mUserHeight;
STATIC UINTN                                mConsoleWidth;
STATIC UINTN                                mConsoleHeight;
STATIC UINTN                                mConsoleMaxPosX;
STATIC UINTN                                mConsoleMaxPosY;
STATIC BOOLEAN                              mConsoleUncontrolled;
STATIC UINTN                                mPrivateColumn; ///< At least UEFI Shell trashes Mode values.
STATIC UINTN                                mPrivateRow;    ///< At least UEFI Shell trashes Mode values.
STATIC UINT32                               mConsoleGopMode;
STATIC UINT8                                mUIScale;
STATIC UINT8                                mFontScale;
STATIC EFI_GRAPHICS_OUTPUT_BLT_PIXEL_UNION  mBackgroundColor;
STATIC EFI_GRAPHICS_OUTPUT_BLT_PIXEL_UNION  mForegroundColor;
STATIC EFI_GRAPHICS_OUTPUT_BLT_PIXEL_UNION  *mCharacterBuffer;
STATIC EFI_CONSOLE_CONTROL_SCREEN_MODE      mConsoleMode = EfiConsoleControlScreenText;

#define TGT_CHAR_WIDTH     ((UINTN)(ISO_CHAR_WIDTH) * mFontScale)
#define TGT_CHAR_HEIGHT    ((UINTN)(ISO_CHAR_HEIGHT) * mFontScale)
#define TGT_CHAR_AREA      ((TGT_CHAR_WIDTH) * (TGT_CHAR_HEIGHT))
#define TGT_PADD_WIDTH     (mConsolePaddingX)
#define TGT_PADD_HEIGHT    (mConsolePaddingY)
#define TGT_CURSOR_X       mFontScale
#define TGT_CURSOR_Y       ((TGT_CHAR_HEIGHT) - mFontScale)
#define TGT_CURSOR_WIDTH   ((TGT_CHAR_WIDTH) - mFontScale * 2)
#define TGT_CURSOR_HEIGHT  (mFontScale)

#define MIN_SUPPORTED_CONSOLE_WIDTH   (80)
#define MIN_SUPPORTED_CONSOLE_HEIGHT  (25)

/**
  Render character onscreen.

  @param[in]  Char  Character code.
  @param[in]  PosX  Character X position.
  @param[in]  PosY  Character Y position.
**/
STATIC
VOID
RenderChar (
  IN CHAR16  Char,
  IN UINTN   PosX,
  IN UINTN   PosY
  )
{
  UINT32        *DstBuffer;
  UINT8         *SrcBuffer;
  UINT32        Line;
  UINT32        Index;
  UINT32        Index2;
  UINT8         Mask;
  UINTN         PageNumber;
  UINT8         PageChar;
  UINT8         PageCharMin;
  UNICODE_PAGE  *Page;
  UINTN         FontHead;
  UINTN         FontTail;
  UINT8         *CharData;
  UINT8         GlyphIndex;
  BOOLEAN       LeftToRight;

  DstBuffer = &mCharacterBuffer[0].Raw;

  //
  // Page 0 and 1 data are optimised to only include non-blank chars, but all other chars in original font
  // are blank and should be rendered as such. Page 0 and 1 also save space by not holding font data for
  // top or bottom lines which are blank in every char in that page, in the original font.
  //
  if (  ((Char >= 0) && (Char < PAGE0_CHAR_MIN))
     || (Char == ' ')
     || (Char == CHAR_TAB)
     || ((Char >= PAGE0_CHAR_MAX) && (Char < (PAGE1_CHAR_MIN + 0x80)))
     || ((Char >= (PAGE1_CHAR_MAX + 0x80)) && (Char < 0x100))
        )
  {
    SetMem32 (DstBuffer, TGT_CHAR_AREA * sizeof (DstBuffer[0]), mBackgroundColor.Raw);
  } else {
    PageNumber = (Char >> 7) & 0x1FF;
    PageChar   = Char & 0x7F;
    if (PageNumber == 0) {
      LeftToRight = FALSE;
      FontHead    = PAGE0_FONT_HEAD;
      FontTail    = PAGE0_FONT_TAIL;
      PageCharMin = PAGE0_CHAR_MIN;
      CharData    = mIsoFontDataPage0;
    } else if (PageNumber == 1) {
      LeftToRight = FALSE;
      FontHead    = PAGE1_FONT_HEAD;
      FontTail    = PAGE1_FONT_TAIL;
      PageCharMin = PAGE1_CHAR_MIN;
      CharData    = mIsoFontDataPage1;
    } else {
      GlyphIndex = 0;

      if ((PageNumber >= ADDITIONAL_FONT_PAGE_MIN) && (PageNumber < ADDITIONAL_FONT_PAGE_MAX)) {
        Page = &mUnicodePages[PageNumber - ADDITIONAL_FONT_PAGE_MIN];
        if ((PageChar >= Page->Min) && (PageChar < Page->Max)) {
          ASSERT (Page->Glyphs  != NULL);
          ASSERT (Page->Offsets != NULL);
          GlyphIndex = Page->Offsets[PageChar - Page->Min];
        }
      }

      //
      // Render all unknown chars as standard font underscore.
      //
      if (GlyphIndex == 0) {
        LeftToRight = FALSE;
        FontHead    = PAGE0_FONT_HEAD;
        FontTail    = PAGE0_FONT_TAIL;
        PageCharMin = PAGE0_CHAR_MIN;
        PageChar    = L'_' & 0x7F;
        CharData    = mIsoFontDataPage0;
      } else {
        LeftToRight = Page->LeftToRight;
        FontHead    = 0;
        FontTail    = 0;
        PageCharMin = 0;
        PageChar    = 0;
        CharData    = &Page->Glyphs[ISO_CHAR_HEIGHT * (GlyphIndex - 1)];
      }
    }

    SrcBuffer = CharData + ((PageChar - PageCharMin) * (ISO_CHAR_HEIGHT - FontHead - FontTail));

    for (Line = 0; Line < FontHead; ++Line) {
      SetMem32 (DstBuffer, TGT_CHAR_WIDTH * mFontScale * sizeof (DstBuffer[0]), mBackgroundColor.Raw); ///< Apply scale twice, for width and height.
      DstBuffer += TGT_CHAR_WIDTH * mFontScale;
    }

    for ( ; Line < ISO_CHAR_HEIGHT - FontTail; ++Line) {
      //
      // Iterate, while the single bit scans font.
      //
      for (Index = 0; Index < mFontScale; ++Index) {
        Mask = LeftToRight ? 0x80 : 1;
        do {
          for (Index2 = 0; Index2 < mFontScale; ++Index2) {
            *DstBuffer = (*SrcBuffer & Mask) ? mForegroundColor.Raw : mBackgroundColor.Raw;
            ++DstBuffer;
          }

          if (LeftToRight) {
            Mask >>= 1U;
          } else {
            Mask <<= 1U;
          }
        } while (Mask != 0);
      }

      ++SrcBuffer;
    }

    for ( ; Line < ISO_CHAR_HEIGHT; ++Line) {
      SetMem32 (DstBuffer, TGT_CHAR_WIDTH * mFontScale * sizeof (DstBuffer[0]), mBackgroundColor.Raw);
      DstBuffer += TGT_CHAR_WIDTH * mFontScale;
    }

    ASSERT (DstBuffer - &mCharacterBuffer[0].Raw == (INTN)TGT_CHAR_AREA);
  }

  mGraphicsOutput->Blt (
                     mGraphicsOutput,
                     &mCharacterBuffer[0].Pixel,
                     EfiBltBufferToVideo,
                     0,
                     0,
                     TGT_PADD_WIDTH  + PosX * TGT_CHAR_WIDTH,
                     TGT_PADD_HEIGHT + PosY * TGT_CHAR_HEIGHT,
                     TGT_CHAR_WIDTH,
                     TGT_CHAR_HEIGHT,
                     0
                     );
}

/**
  Swap cursor visibility onscreen.

  @param[in]  Enabled  Whether cursor is visible.
  @param[in]  PosX     Character X position.
  @param[in]  PosY     Character Y position.
**/
STATIC
VOID
FlushCursor (
  IN BOOLEAN  Enabled,
  IN UINTN    PosX,
  IN UINTN    PosY
  )
{
  EFI_STATUS                           Status;
  EFI_GRAPHICS_OUTPUT_BLT_PIXEL_UNION  Colour;

  if (!Enabled || (mConsoleMode != EfiConsoleControlScreenText)) {
    return;
  }

  //
  // UEFI only has one cursor at a time. UEFI Shell edit command has a cursor and a mouse
  // pointer, which are not connected. To be able to draw both at a time UEFI Shell constantly
  // redraws both the cursor and the mouse pointer. To do that it constantly flips bg and fg
  // colours as well as cursor visibility.
  // It seems that the Shell implementation relies on an undocumented feature (is that a bug?)
  // of hiding an already drawn cursor with a space with inverted attributes.
  // This is weird but EDK II implementation seems to match the logic, and as a result we
  // track cursor visibility or easily optimise this logic.
  //
  Status = mGraphicsOutput->Blt (
                              mGraphicsOutput,
                              &Colour.Pixel,
                              EfiBltVideoToBltBuffer,
                              TGT_PADD_WIDTH  + PosX * TGT_CHAR_WIDTH  + TGT_CURSOR_X,
                              TGT_PADD_HEIGHT + PosY * TGT_CHAR_HEIGHT + TGT_CURSOR_Y,
                              0,
                              0,
                              1,
                              1,
                              0
                              );

  if (EFI_ERROR (Status)) {
    return;
  }

  mGraphicsOutput->Blt (
                     mGraphicsOutput,
                     Colour.Raw == mForegroundColor.Raw ? &mBackgroundColor.Pixel : &mForegroundColor.Pixel,
                     EfiBltVideoFill,
                     0,
                     0,
                     TGT_PADD_WIDTH  + PosX * TGT_CHAR_WIDTH  + TGT_CURSOR_X,
                     TGT_PADD_HEIGHT + PosY * TGT_CHAR_HEIGHT + TGT_CURSOR_Y,
                     TGT_CURSOR_WIDTH,
                     TGT_CURSOR_HEIGHT,
                     0
                     );
}

STATIC
VOID
RenderScroll (
  VOID
  )
{
  UINTN  Width;

  //
  // Move used screen region.
  //
  Width = (mConsoleMaxPosX + 1) * TGT_CHAR_WIDTH;
  mGraphicsOutput->Blt (
                     mGraphicsOutput,
                     NULL,
                     EfiBltVideoToVideo,
                     TGT_PADD_WIDTH,
                     TGT_PADD_HEIGHT + TGT_CHAR_HEIGHT,
                     TGT_PADD_WIDTH,
                     TGT_PADD_HEIGHT,
                     Width,
                     TGT_CHAR_HEIGHT * (mConsoleHeight - 1),
                     0
                     );

  //
  // Erase last line.
  //
  mGraphicsOutput->Blt (
                     mGraphicsOutput,
                     &mBackgroundColor.Pixel,
                     EfiBltVideoFill,
                     0,
                     0,
                     TGT_PADD_WIDTH,
                     TGT_PADD_HEIGHT + TGT_CHAR_HEIGHT * (mConsoleHeight - 1),
                     Width,
                     TGT_CHAR_HEIGHT,
                     0
                     );
}

//
// Resync - called on detected change of GOP mode and on reset.
//
STATIC
EFI_STATUS
RenderResync (
  IN EFI_SIMPLE_TEXT_OUTPUT_PROTOCOL  *This
  )
{
  EFI_GRAPHICS_OUTPUT_MODE_INFORMATION  *Info;
  UINTN                                 MaxWidth;
  UINTN                                 MaxHeight;

  Info = mGraphicsOutput->Mode->Info;

  //
  // Require space for at least 1x1 chars on the calculation below.
  //
  if (  (Info->HorizontalResolution < ISO_CHAR_WIDTH)
     || (Info->VerticalResolution   < ISO_CHAR_HEIGHT))
  {
    return EFI_LOAD_ERROR;
  }

  if (mCharacterBuffer != NULL) {
    FreePool (mCharacterBuffer);
  }

  //
  // Reset font scale and allocate for target size - may be over-allocated if we have to override below.
  //
  mFontScale       = mUIScale;
  mCharacterBuffer = AllocatePool (TGT_CHAR_AREA * sizeof (mCharacterBuffer[0]));
  if (mCharacterBuffer == NULL) {
    return EFI_OUT_OF_RESOURCES;
  }

  mConsoleGopMode = mGraphicsOutput->Mode->Mode;

  //
  // Override font scale to reach minimum supported text resolution, if needed and possible.
  //
  while (TRUE) {
    MaxWidth  = Info->HorizontalResolution / TGT_CHAR_WIDTH;
    MaxHeight = Info->VerticalResolution / TGT_CHAR_HEIGHT;
    if (  (MaxWidth  >= MIN_SUPPORTED_CONSOLE_WIDTH)
       && (MaxHeight >= MIN_SUPPORTED_CONSOLE_HEIGHT))
    {
      break;
    }

    if (mFontScale == 1) {
      break;
    }

    mFontScale = 1;
  }

  if ((mUserWidth == 0) || (mUserHeight == 0)) {
    mConsoleWidth  = MaxWidth;
    mConsoleHeight = MaxHeight;
  } else {
    mConsoleWidth  = MIN (MaxWidth, mUserWidth);
    mConsoleHeight = MIN (MaxHeight, mUserHeight);
  }

  mConsolePaddingX     = (Info->HorizontalResolution - (mConsoleWidth * TGT_CHAR_WIDTH)) / 2;
  mConsolePaddingY     = (Info->VerticalResolution - (mConsoleHeight * TGT_CHAR_HEIGHT)) / 2;
  mConsoleMaxPosX      = 0;
  mConsoleMaxPosY      = 0;
  mConsoleUncontrolled = FALSE;

  mPrivateColumn           = mPrivateRow = 0;
  This->Mode->CursorColumn = This->Mode->CursorRow = 0;

  //
  // Avoid rendering any console content when in graphics mode.
  //
  if (mConsoleMode == EfiConsoleControlScreenText) {
    mGraphicsOutput->Blt (
                       mGraphicsOutput,
                       &mBackgroundColor.Pixel,
                       EfiBltVideoFill,
                       0,
                       0,
                       0,
                       0,
                       Info->HorizontalResolution,
                       Info->VerticalResolution,
                       0
                       );
  }

  return EFI_SUCCESS;
}

STATIC
EFI_STATUS
EFIAPI
AsciiTextResetEx (
  IN EFI_SIMPLE_TEXT_OUTPUT_PROTOCOL  *This,
  IN BOOLEAN                          ExtendedVerification,
  IN BOOLEAN                          Debug
  )
{
  EFI_STATUS  Status;
  EFI_TPL     OldTpl;

  OldTpl = gBS->RaiseTPL (TPL_NOTIFY);

  Status = OcHandleProtocolFallback (
             gST->ConsoleOutHandle,
             &gEfiGraphicsOutputProtocolGuid,
             (VOID **)&mGraphicsOutput
             );

  if (EFI_ERROR (Status)) {
    gBS->RestoreTPL (OldTpl);
    if (Debug) {
      DEBUG ((DEBUG_INFO, "OCC: ASCII Text Reset [HandleProtocolFallback] - %r\n", Status));
      return Status;
    }

    return EFI_DEVICE_ERROR;
  }

  This->Mode->MaxMode   = 1;
  This->Mode->Attribute = ARRAY_SIZE (mGraphicsEfiColors) / 2 - 1;
  mBackgroundColor.Raw  = mGraphicsEfiColors[0];
  mForegroundColor.Raw  = mGraphicsEfiColors[ARRAY_SIZE (mGraphicsEfiColors) / 2 - 1];

  Status = RenderResync (This);
  gBS->RestoreTPL (OldTpl);
  if (EFI_ERROR (Status)) {
    if (Debug) {
      DEBUG ((DEBUG_INFO, "OCC: ASCII Text Reset [RenderResync] - %r\n", Status));
      return Status;
    }

    return EFI_DEVICE_ERROR;
  }

  return EFI_SUCCESS;
}

STATIC
EFI_STATUS
EFIAPI
AsciiTextReset (
  IN EFI_SIMPLE_TEXT_OUTPUT_PROTOCOL  *This,
  IN BOOLEAN                          ExtendedVerification
  )
{
  EFI_STATUS  Status;

  Status = AsciiTextResetEx (This, ExtendedVerification, FALSE);
  return Status;
}

STATIC
EFI_STATUS
EFIAPI
AsciiTextOutputString (
  IN EFI_SIMPLE_TEXT_OUTPUT_PROTOCOL  *This,
  IN CHAR16                           *String
  )
{
  UINTN       Index;
  EFI_TPL     OldTpl;
  EFI_STATUS  Status;

  //
  // Do not print text in graphics mode.
  //
  if (mConsoleMode != EfiConsoleControlScreenText) {
    return EFI_UNSUPPORTED;
  }

  OldTpl = gBS->RaiseTPL (TPL_NOTIFY);

  //
  // Do not print in different modes.
  //
  if (mConsoleGopMode != mGraphicsOutput->Mode->Mode) {
    Status = RenderResync (This);
    if (EFI_ERROR (Status)) {
      gBS->RestoreTPL (OldTpl);
      return EFI_DEVICE_ERROR;
    }
  }

  //
  // For whatever reason UEFI Shell trashes these values when executing commands like help -b.
  //
  This->Mode->CursorColumn = (INT32)mPrivateColumn;
  This->Mode->CursorRow    = (INT32)mPrivateRow;

  FlushCursor (This->Mode->CursorVisible, This->Mode->CursorColumn, This->Mode->CursorRow);

  for (Index = 0; String[Index] != '\0'; ++Index) {
    //
    // Carriage return should just move the cursor back.
    //
    if (String[Index] == CHAR_CARRIAGE_RETURN) {
      This->Mode->CursorColumn = 0;
      continue;
    }

    if (String[Index] == CHAR_BACKSPACE) {
      if ((This->Mode->CursorColumn == 0) && (This->Mode->CursorRow > 0)) {
        This->Mode->CursorRow--;
        This->Mode->CursorColumn = (INT32)(mConsoleWidth - 1);
        RenderChar (' ', This->Mode->CursorColumn, This->Mode->CursorRow);
      } else if (This->Mode->CursorColumn > 0) {
        This->Mode->CursorColumn--;
        RenderChar (' ', This->Mode->CursorColumn, This->Mode->CursorRow);
      }

      continue;
    }

    //
    // Newline should move the cursor lower.
    // In case we are out of room it should scroll instead.
    //
    if (String[Index] == CHAR_LINEFEED) {
      if ((UINTN)This->Mode->CursorRow < mConsoleHeight - 1) {
        ++This->Mode->CursorRow;
        mConsoleMaxPosY = MAX (mConsoleMaxPosY, (UINTN)This->Mode->CursorRow);
      } else {
        RenderScroll ();
      }

      continue;
    }

    //
    // Render normal symbol and decide on next cursor position.
    //
    RenderChar (String[Index], This->Mode->CursorColumn, This->Mode->CursorRow);
    if ((UINTN)This->Mode->CursorColumn < mConsoleWidth - 1) {
      //
      // Continues on the same line.
      //
      ++This->Mode->CursorColumn;
      mConsoleMaxPosX = MAX (mConsoleMaxPosX, (UINTN)This->Mode->CursorColumn);
    } else if ((UINTN)This->Mode->CursorRow < mConsoleHeight - 1) {
      //
      // New line without scroll.
      //
      This->Mode->CursorColumn = 0;
      ++This->Mode->CursorRow;
      mConsoleMaxPosY = MAX (mConsoleMaxPosY, (UINTN)This->Mode->CursorRow);
    } else {
      //
      // New line with scroll.
      //
      RenderScroll ();
      This->Mode->CursorColumn = 0;
    }
  }

  FlushCursor (This->Mode->CursorVisible, This->Mode->CursorColumn, This->Mode->CursorRow);

  mPrivateColumn = (UINTN)This->Mode->CursorColumn;
  mPrivateRow    = (UINTN)This->Mode->CursorRow;

  gBS->RestoreTPL (OldTpl);

  return EFI_SUCCESS;
}

STATIC
EFI_STATUS
EFIAPI
AsciiTextTestString (
  IN EFI_SIMPLE_TEXT_OUTPUT_PROTOCOL  *This,
  IN CHAR16                           *String
  )
{
  if (StrCmp (String, OC_CONSOLE_MARK_UNCONTROLLED) == 0) {
    mConsoleUncontrolled = TRUE;
  }

  return EFI_SUCCESS;
}

STATIC
EFI_STATUS
EFIAPI
AsciiTextQueryMode (
  IN  EFI_SIMPLE_TEXT_OUTPUT_PROTOCOL  *This,
  IN  UINTN                            ModeNumber,
  OUT UINTN                            *Columns,
  OUT UINTN                            *Rows
  )
{
  EFI_STATUS  Status;
  EFI_TPL     OldTpl;

  OldTpl = gBS->RaiseTPL (TPL_NOTIFY);

  if (mConsoleGopMode != mGraphicsOutput->Mode->Mode) {
    Status = RenderResync (This);
    if (EFI_ERROR (Status)) {
      gBS->RestoreTPL (OldTpl);
      return EFI_DEVICE_ERROR;
    }
  }

  if (ModeNumber == 0) {
    *Columns = mConsoleWidth;
    *Rows    = mConsoleHeight;
    Status   = EFI_SUCCESS;
  } else {
    Status = EFI_UNSUPPORTED;
  }

  gBS->RestoreTPL (OldTpl);

  return Status;
}

STATIC
EFI_STATUS
EFIAPI
AsciiTextSetMode (
  IN EFI_SIMPLE_TEXT_OUTPUT_PROTOCOL  *This,
  IN UINTN                            ModeNumber
  )
{
  EFI_STATUS  Status;
  EFI_TPL     OldTpl;

  if (ModeNumber != 0) {
    return EFI_UNSUPPORTED;
  }

  if (mConsoleGopMode != mGraphicsOutput->Mode->Mode) {
    OldTpl = gBS->RaiseTPL (TPL_NOTIFY);
    Status = RenderResync (This);
    gBS->RestoreTPL (OldTpl);
    if (EFI_ERROR (Status)) {
      return EFI_DEVICE_ERROR;
    }
  }

  return EFI_SUCCESS;
}

STATIC
EFI_STATUS
EFIAPI
AsciiTextSetAttribute (
  IN EFI_SIMPLE_TEXT_OUTPUT_PROTOCOL  *This,
  IN UINTN                            Attribute
  )
{
  EFI_STATUS  Status;
  UINT32      FgColor;
  UINT32      BgColor;
  EFI_TPL     OldTpl;

  if ((Attribute & ~0x7FU) != 0) {
    return EFI_UNSUPPORTED;
  }

  OldTpl = gBS->RaiseTPL (TPL_NOTIFY);

  if (mConsoleGopMode != mGraphicsOutput->Mode->Mode) {
    Status = RenderResync (This);
    if (EFI_ERROR (Status)) {
      gBS->RestoreTPL (OldTpl);
      return EFI_DEVICE_ERROR;
    }
  }

  if (Attribute != (UINTN)This->Mode->Attribute) {
    FlushCursor (This->Mode->CursorVisible, mPrivateColumn, mPrivateRow);

    FgColor = BitFieldRead32 ((UINT32)Attribute, 0, 3);
    BgColor = BitFieldRead32 ((UINT32)Attribute, 4, 6);

    //
    // Once we change the background colour, any clear screen must cover the whole screen.
    //
    if (mGraphicsEfiColors[BgColor] != mBackgroundColor.Raw) {
      mConsoleUncontrolled = TRUE;
    }

    mForegroundColor.Raw  = mGraphicsEfiColors[FgColor];
    mBackgroundColor.Raw  = mGraphicsEfiColors[BgColor];
    This->Mode->Attribute = (UINT32)Attribute;

    FlushCursor (This->Mode->CursorVisible, mPrivateColumn, mPrivateRow);
  }

  gBS->RestoreTPL (OldTpl);
  return EFI_SUCCESS;
}

//
// Note: This intentionally performs a partial screen clear, affecting only the
// area containing text which has been written using our renderer, unless console
// is marked uncontrolled prior to clearing.
//
STATIC
EFI_STATUS
EFIAPI
AsciiTextClearScreen (
  IN EFI_SIMPLE_TEXT_OUTPUT_PROTOCOL  *This
  )
{
  EFI_STATUS  Status;
  UINTN       Width;
  UINTN       Height;
  EFI_TPL     OldTpl;

  //
  // Note: We stay marked uncontrolled, if staying in graphics mode.
  //
  if (mConsoleMode != EfiConsoleControlScreenText) {
    return EFI_UNSUPPORTED;
  }

  OldTpl = gBS->RaiseTPL (TPL_NOTIFY);

  //
  // No need to re-clear screen straight after resync; but note that the initial screen
  // clear after resync, although of non-zero size, is intentionally very lightweight.
  //
  if (mConsoleGopMode != mGraphicsOutput->Mode->Mode) {
    Status = RenderResync (This);
    if (EFI_ERROR (Status)) {
      gBS->RestoreTPL (OldTpl);
      return EFI_DEVICE_ERROR;
    }
  } else {
    //
    // When controlled, we assume that only text which we rendered needs to be cleared.
    // When marked uncontrolled anyone may have put content (in particular, graphics) anywhere
    // so always clear full screen.
    //
    if (mConsoleUncontrolled) {
      mGraphicsOutput->Blt (
                         mGraphicsOutput,
                         &mBackgroundColor.Pixel,
                         EfiBltVideoFill,
                         0,
                         0,
                         0,
                         0,
                         mGraphicsOutput->Mode->Info->HorizontalResolution,
                         mGraphicsOutput->Mode->Info->VerticalResolution,
                         0
                         );

      mConsoleUncontrolled = FALSE;
    } else {
      //
      // mConsoleMaxPosX,Y coordinates are the top left coordinates of the of the greatest
      // occupied character position. Because there is a cursor, there is always at least
      // one character position occupied.
      //
      Width  = (mConsoleMaxPosX + 1) * TGT_CHAR_WIDTH;
      Height = (mConsoleMaxPosY + 1) * TGT_CHAR_HEIGHT;
      ASSERT (TGT_PADD_WIDTH  + Width <= mGraphicsOutput->Mode->Info->HorizontalResolution);
      ASSERT (TGT_PADD_HEIGHT + Height <= mGraphicsOutput->Mode->Info->VerticalResolution);

      mGraphicsOutput->Blt (
                         mGraphicsOutput,
                         &mBackgroundColor.Pixel,
                         EfiBltVideoFill,
                         0,
                         0,
                         TGT_PADD_WIDTH,
                         TGT_PADD_HEIGHT,
                         Width,
                         Height,
                         0
                         );
    }
  }

  //
  // Handle cursor.
  //
  mPrivateColumn           = mPrivateRow = 0;
  This->Mode->CursorColumn = This->Mode->CursorRow = 0;
  FlushCursor (This->Mode->CursorVisible, mPrivateColumn, mPrivateRow);

  //
  // After clear screen, shell may scroll through old text via page up/down buttons,
  // but it is okay to reset max x/y here anyway, as any old text is brought on via
  // full redraw.
  //
  mConsoleMaxPosX = 0;
  mConsoleMaxPosY = 0;

  gBS->RestoreTPL (OldTpl);
  return EFI_SUCCESS;
}

STATIC
EFI_STATUS
EFIAPI
AsciiTextSetCursorPosition (
  IN EFI_SIMPLE_TEXT_OUTPUT_PROTOCOL  *This,
  IN UINTN                            Column,
  IN UINTN                            Row
  )
{
  EFI_STATUS  Status;
  EFI_TPL     OldTpl;

  OldTpl = gBS->RaiseTPL (TPL_NOTIFY);

  if (mConsoleGopMode != mGraphicsOutput->Mode->Mode) {
    Status = RenderResync (This);
    if (EFI_ERROR (Status)) {
      gBS->RestoreTPL (OldTpl);
      return EFI_DEVICE_ERROR;
    }
  }

  //
  // Clamping the row here successfully works round a bug in memtest86 where it
  // does not re-read console text resolution when it changes the graphics mode.
  // If changing between text resolutions >= 80x25, the issue is only visible
  // in the position of the footer line on the text UI screen, and this fixes it.
  //
  if (Column >= mConsoleWidth) {
    Column = mConsoleWidth - 1;
  }

  if (Row >= mConsoleHeight) {
    Row = mConsoleHeight - 1;
  }

  if ((Column < mConsoleWidth) && (Row < mConsoleHeight)) {
    FlushCursor (This->Mode->CursorVisible, mPrivateColumn, mPrivateRow);
    mPrivateColumn           = Column;
    mPrivateRow              = Row;
    This->Mode->CursorColumn = (INT32)mPrivateColumn;
    This->Mode->CursorRow    = (INT32)mPrivateRow;
    FlushCursor (This->Mode->CursorVisible, mPrivateColumn, mPrivateRow);
    mConsoleMaxPosX = MAX (mConsoleMaxPosX, Column);
    mConsoleMaxPosY = MAX (mConsoleMaxPosY, Row);
    Status          = EFI_SUCCESS;
  } else {
    Status = EFI_UNSUPPORTED;
  }

  gBS->RestoreTPL (OldTpl);
  return Status;
}

STATIC
EFI_STATUS
EFIAPI
AsciiTextEnableCursor (
  IN EFI_SIMPLE_TEXT_OUTPUT_PROTOCOL  *This,
  IN BOOLEAN                          Visible
  )
{
  EFI_STATUS  Status;
  EFI_TPL     OldTpl;

  OldTpl = gBS->RaiseTPL (TPL_NOTIFY);

  if (mConsoleGopMode != mGraphicsOutput->Mode->Mode) {
    Status = RenderResync (This);
    if (EFI_ERROR (Status)) {
      gBS->RestoreTPL (OldTpl);
      return EFI_DEVICE_ERROR;
    }
  }

  FlushCursor (This->Mode->CursorVisible, mPrivateColumn, mPrivateRow);
  This->Mode->CursorVisible = Visible;
  FlushCursor (This->Mode->CursorVisible, mPrivateColumn, mPrivateRow);
  gBS->RestoreTPL (OldTpl);
  return EFI_SUCCESS;
}

STATIC
EFI_SIMPLE_TEXT_OUTPUT_MODE
  mAsciiTextOutputMode;

STATIC
EFI_SIMPLE_TEXT_OUTPUT_PROTOCOL
  mAsciiTextOutputProtocol = {
  AsciiTextReset,
  AsciiTextOutputString,
  AsciiTextTestString,
  AsciiTextQueryMode,
  AsciiTextSetMode,
  AsciiTextSetAttribute,
  AsciiTextClearScreen,
  AsciiTextSetCursorPosition,
  AsciiTextEnableCursor,
  &mAsciiTextOutputMode
};

STATIC
EFI_STATUS
EFIAPI
ConsoleControlGetMode (
  IN   EFI_CONSOLE_CONTROL_PROTOCOL     *This,
  OUT  EFI_CONSOLE_CONTROL_SCREEN_MODE  *Mode,
  OUT  BOOLEAN                          *GopUgaExists OPTIONAL,
  OUT  BOOLEAN                          *StdInLocked  OPTIONAL
  )
{
  *Mode = mConsoleMode;

  if (GopUgaExists != NULL) {
    *GopUgaExists = TRUE;
  }

  if (StdInLocked != NULL) {
    *StdInLocked = FALSE;
  }

  return EFI_SUCCESS;
}

STATIC
EFI_STATUS
EFIAPI
ConsoleControlSetMode (
  IN EFI_CONSOLE_CONTROL_PROTOCOL     *This,
  IN EFI_CONSOLE_CONTROL_SCREEN_MODE  Mode
  )
{
  if (mConsoleMode != Mode) {
    mConsoleMode = Mode;

    //
    // If controlled, switching to graphics then back to text should change nothing.
    //
    if (  (mConsoleMode == EfiConsoleControlScreenText)
       && mConsoleUncontrolled)
    {
      gST->ConOut->ClearScreen (gST->ConOut);
    }
  }

  return EFI_SUCCESS;
}

STATIC
EFI_STATUS
EFIAPI
ConsoleControlLockStdIn (
  IN EFI_CONSOLE_CONTROL_PROTOCOL  *This,
  IN CHAR16                        *Password
  )
{
  return EFI_DEVICE_ERROR;
}

STATIC
EFI_CONSOLE_CONTROL_PROTOCOL
  mConsoleControlProtocol = {
  ConsoleControlGetMode,
  ConsoleControlSetMode,
  ConsoleControlLockStdIn
};

EFI_STATUS
OcUseBuiltinTextOutput (
  IN EFI_CONSOLE_CONTROL_SCREEN_MODE  InitialMode,
  IN EFI_CONSOLE_CONTROL_SCREEN_MODE  Mode,
  IN UINT32                           Width,
  IN UINT32                           Height
  )
{
  EFI_STATUS                    Status;
  UINTN                         UiScaleSize;
  EFI_CONSOLE_CONTROL_PROTOCOL  OriginalConsoleControlProtocol;

  UiScaleSize = sizeof (mUIScale);

  Status = gRT->GetVariable (
                  APPLE_UI_SCALE_VARIABLE_NAME,
                  &gAppleVendorVariableGuid,
                  NULL,
                  &UiScaleSize,
                  (VOID *)&mUIScale
                  );

  if (EFI_ERROR (Status) || (mUIScale != 2)) {
    mUIScale = 1;
  }

  mFontScale = mUIScale;

  DEBUG ((DEBUG_INFO, "OCC: Using builtin text renderer with %d scale\n", mUIScale));

  mUserWidth   = Width;
  mUserHeight  = Height;
  mConsoleMode = InitialMode;
  OcConsoleControlSetMode (Mode);
  Status = OcConsoleControlInstallProtocol (&mConsoleControlProtocol, &OriginalConsoleControlProtocol, NULL); ///< Produces o/p using old, uncontrolled text protocol
  if (!EFI_ERROR (Status)) {
    Status = AsciiTextResetEx (&mAsciiTextOutputProtocol, TRUE, TRUE); ///< Prepare new text protocol (sets new font size, clears screen)
    if (EFI_ERROR (Status)) {
      OcConsoleControlRestoreProtocol (&OriginalConsoleControlProtocol);
    } else {
      gST->ConOut    = &mAsciiTextOutputProtocol; ///< Install new text protocol
      gST->Hdr.CRC32 = 0;

      gBS->CalculateCrc32 (
             gST,
             gST->Hdr.HeaderSize,
             &gST->Hdr.CRC32
             );
    }
  }

  DEBUG ((DEBUG_INFO, "OCC: Setup ASCII Output - %r\n", Status));

  return Status;
}
